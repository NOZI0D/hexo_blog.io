<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Dockerfile</title>
    <url>/2019/10/24/Dockerfile/</url>
    <content><![CDATA[<p><code>Dockerfile</code>是一个包含用于组合映像的命令的文本文档。可以使用在命令行中调用任何命令。<br>Docker通过读取Dockerfile中的指令自动生成映像。</p>
<p><code>docker build</code>命令用于从Dockerfile构建映像。<br>可以在<code>docker build</code>命令中使用<code>-f</code>标志指向文件系统中任何位置的Dockerfile。</p>
<p>常用命令的说明</p>
<hr>
<p>Docker以从上到下的顺序运行Dockerfile的指令。<br>为了指定基本映像，第一条指令必须是FROM。<br>一个声明以＃字符开头则被视为注释。可以在Docker文件中使用<code>RUN</code>，<code>CMD</code>，<code>FROM</code>，<code>EXPOSE</code>，<code>ENV</code>等指令。</p>
<p>一些基本命令的说明：</p>
<h4 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h4><p>该指令用于设置后续指令的基本映像。有效的Dockerfile必须使用<code>FROM</code>作为其第一条指令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span><br></pre></td></tr></table></figure>

<h4 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h4><p>指定作者<br>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MAINTAINER &lt;name&gt;</span><br></pre></td></tr></table></figure>

<h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><p>功能为暴漏容器运行时的监听端口给外部<br>但是EXPOSE并不会使容器访问主机的端口<br>如果想使得容器与主机的端口有映射关系，必须在容器启动的时候加上 -P参数</p>
<h4 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h4><p>功能为设置环境变量<br>语法有两种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. ENV &lt;key&gt;&lt;value&gt;</span><br><span class="line">2. ENV &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure>

<p>两者的区别就是第一种是一次设置一个，第二种是一次设置多个</p>
<h4 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h4><p>用来标明dockerfile的标签 可以使用Label代替Maintainer 最终都是在docker image基本信息中可以查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LABEL &lt;key&gt;=&lt;value&gt;</span><br></pre></td></tr></table></figure>

<h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><p>功能为运行指定的命令,RUN命令有两种格式</p>
<figure class="highlight plain"><figcaption><span><command></span></figcaption><table><tr><td class="code"><pre><span class="line">RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</span><br></pre></td></tr></table></figure>

<p>第一种后边直接跟shell命令<br>在linux操作系统上默认 /bin/sh -c<br>在windows操作系统上默认 cmd /S /C</p>
<p>两种写法比对：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. RUN /bin/bash -c &apos;source $HOME/.bashrc; echo $HOME</span><br><span class="line">2. RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</span><br></pre></td></tr></table></figure>

<p>注意：多行命令不要写多个RUN，原因是Dockerfile中每一个指令都会建立一层.多少个RUN就构建了多少层镜像，会造成镜像的臃肿、多层，不仅仅增加了构件部署的时间，还容易出错。RUN书写时的换行符是\</p>
<h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>容器启动时要运行的命令，有三种写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</span><br><span class="line">2. CMD [&quot;param1&quot;,&quot;param2&quot;]</span><br><span class="line">3. CMD command param1 param2</span><br></pre></td></tr></table></figure>

<p>第三种比较好理解了，就是shell这种执行方式和写法<br>第一种和第二种其实都是可执行文件加上参数的形式</p>
<p>举例说明两种写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot;</span><br><span class="line">2. CMD [ &quot;echo&quot;, &quot;$HOME&quot; ]</span><br></pre></td></tr></table></figure>

<p>补充：这里边包括参数的一定要用双引号，就是”,不能是单引号。千万不能写成单引号。<br>原因是参数传递后，docker解析的是一个JSON array</p>
<h4 id="RUN-amp-CMD-的区别"><a href="#RUN-amp-CMD-的区别" class="headerlink" title="RUN &amp; CMD 的区别"></a>RUN &amp; CMD 的区别</h4><p>RUN是构件容器时就运行的命令以及提交运行结果<br>CMD是容器启动时执行的命令，在构件时并不运行，构件时紧紧指定了这个命令到底是个什么样子</p>
<h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><p>把文件复制到镜像中<br>如果把虚拟机与容器想象成两台linux服务器的话，那么这个命令就类似于scp，只是scp需要加用户名和密码的权限验证，而ADD不用。<br>语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. ADD &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">2. ADD [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span><br></pre></td></tr></table></figure>

<p>dest 路径的填写可以是容器内的绝对路径，也可以是相对于工作目录的相对路径<br>src可以是一个本地文件或者是一个本地压缩文件，还可以是一个url<br>如果把src写成一个url，那么ADD就类似于wget命令<br>如以下写法都是可以的： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADD test relativeDir/ </span><br><span class="line">ADD test /relativeDir</span><br><span class="line">ADD http://example.com/foobar /</span><br></pre></td></tr></table></figure>

<p>尽量不要把scr写成一个文件夹，如果src是一个文件夹了，复制整个目录的内容,包括文件系统元数据</p>
<h4 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h4><p>复制命令<br>语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">COPY [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span><br></pre></td></tr></table></figure>

<p>与ADD的区别:<br>COPY的src只能是本地文件，其他用法一致</p>
<hr>
<h4 id="整体逻辑图"><a href="#整体逻辑图" class="headerlink" title="整体逻辑图"></a>整体逻辑图</h4><p>从网上盗了张图  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: )</p>
<p><img src="https://s1.51cto.com/images/blog/201905/27/4bdf2128fa547271a482544e49e47366.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="pic"></p>
]]></content>
  </entry>
</search>
